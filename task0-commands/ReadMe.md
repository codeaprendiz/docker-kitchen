## Contents
- [image](#image)
    - [rm](#rm-id-of-the-image)
- [images](#images)
   



## image
### rm [id-of-the-image]
To remove the image with specific ID
```bash
$ sudo docker images | grep ubuntu
Password:
ubuntu                               latest                     4e5021d210f6        2 weeks ago         64.2MB
 
$ sudo docker image rm 4e5021d210f6
Untagged: ubuntu:latest
Untagged: ubuntu@sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d
Deleted: sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd
Deleted: sha256:1d9112746e9d86157c23e426ce87cc2d7bced0ba2ec8ddbdfbcc3093e0769472
Deleted: sha256:efcf4a93c18b5d01aa8e10a2e3b7e2b2eef0378336456d8653e2d123d6232c1e
Deleted: sha256:1e1aa31289fdca521c403edd6b37317bf0a349a941c7f19b6d9d311f59347502
Deleted: sha256:c8be1b8f4d60d99c281fc2db75e0f56df42a83ad2f0b091621ce19357e19d853
```

## images
To show all the images present
```bash
$ sudo docker images               
Password:
REPOSITORY                           TAG                        IMAGE ID            CREATED             SIZE
ubuntu                               latest                     4e5021d210f6        2 weeks ago         64.2MB
busybox                              latest                     83aa35aa1c79        3 weeks ago         1.22MB
```

## Overview
API Design has come of age, and has become a first-class citizen in the
enterprise. The principles and practices that we follow determine the
usability and overall quality of our APIs. We've seen web sites and
books on the topic, but why do we need an API Design Guide, and what
are the essentials of good API design?




### Resource Identifiers
Resources should use Sequential UUIDs (SQUUIDs).

We chose SQUUIDs because they limit fragmentation of indexes and eliminate [performance problems in MySQL](http://www.percona.com/blog/2007/03/13/to-uuid-or-not-to-uuid/). __SQUUIDs are stored as binary(16)__

_SQUUIDs should be represented in string form as lowercase.  This is so that they can easily be joined across tables in the data warehouse._

#### Do Not Use Database Table Row IDs as Resource IDs
Auto-incrementing integer database row identifiers should not be used as Resource IDs or exposed in any way through the API.

Exposing DB table "auto-increment" row IDs as Resource IDs leaks implementation details outside the API. Row IDs couple the resource too closely to the underlying persistence engine and schema, and can cause headaches when the owning service might need to migrate away from a particular persistence engine or structure, or when clustering of several DBs becomes necessary. IDs not generated by autoincrementing column IDs allow for more flexibility.

#### Sample SQUUID Generator
```
def squuid
  This is basically the implementation of SecureRandom.uuid ...
  ary = SecureRandom.random_bytes(16).unpack("NnnnnN")
  ... but we replace the high-order 32 bits with the current time.
  ary[0] = Time.now.to_i
  ary[2] = (ary[2] & 0x0fff) | 0x4000
  ary[3] = (ary[3] & 0x3fff) | 0x8000
  "%08x-%04x-%04x-%04x-%04x%08x" % ary
end
```

### Versioning

#### Why Versioning?
API Versioning is an important aspect of API design because it informs the consumer about an API's capabilities and data. Consumers use the version number for compatibility.

#### Versioning Methods
Here are 2 of supported methods of API versioning:

* **Version in the HTTP Accept Header.** (*this is our preference*)
* Version in the URI.

We currently have some APIs that use Header-based versioning, and some that use URI-based versioning, in addition to deployed mobile apps that invoke URI-versioned APIs. Here is the direction we would like to take:

* Put the API Version in the HTTP Header for all new development.
* To avoid negatively impacting the current APIs under development, they can continue to use URI-based versioning for the time being.
* As opportunities arise, refactor all URI-versioned APIs to Header-based APIs.

##### Version in the HTTP `Accept` Header

```
GET
/inventory_items/4
Accept: application/vnd.livingsocial.v1+json
```
Here are the pros when putting the version in the HTTP `Accept` Header:

* The version is a representation of a resource, and (according to the [HTTP specification](https://tools.ietf.org/html/rfc2616)) this information goes in the HTTP Accept Header.
* It leverages a mechanism already provided by the HTTP specification. It's good to follow standards, and there's no need to invent something else.
* It is intellectually consistent with [Roy Fielding's dissertation on REST](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm).
* It supports content-based load balancing provided by web servers such as nginx.

Here are the cons:

* It's harder to test because you can't test it from a browser - you can't see the HTTP Headers without additional tooling.
  * But RESTful client plugins take care of this issue, and they are widely available for all major browsers. Plus, there are several good standalone RESTful API test tools.

