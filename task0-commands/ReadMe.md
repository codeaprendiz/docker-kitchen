## Contents
- [image](#image)
    - [rm](#rm-id-of-the-image)
- [images](#images)
   



## image
### rm [id-of-the-image]
To remove the image with specific ID
```bash
$ sudo docker images | grep ubuntu
Password:
ubuntu                               latest                     4e5021d210f6        2 weeks ago         64.2MB
 
$ sudo docker image rm 4e5021d210f6
Untagged: ubuntu:latest
Untagged: ubuntu@sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d
Deleted: sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd
Deleted: sha256:1d9112746e9d86157c23e426ce87cc2d7bced0ba2ec8ddbdfbcc3093e0769472
Deleted: sha256:efcf4a93c18b5d01aa8e10a2e3b7e2b2eef0378336456d8653e2d123d6232c1e
Deleted: sha256:1e1aa31289fdca521c403edd6b37317bf0a349a941c7f19b6d9d311f59347502
Deleted: sha256:c8be1b8f4d60d99c281fc2db75e0f56df42a83ad2f0b091621ce19357e19d853
```

## images
To show all the images present
```bash
$ sudo docker images               
Password:
REPOSITORY                           TAG                        IMAGE ID            CREATED             SIZE
ubuntu                               latest                     4e5021d210f6        2 weeks ago         64.2MB
busybox                              latest                     83aa35aa1c79        3 weeks ago         1.22MB
```

## Overview
API Design has come of age, and has become a first-class citizen in the
enterprise. The principles and practices that we follow determine the
usability and overall quality of our APIs. We've seen web sites and
books on the topic, but why do we need an API Design Guide, and what
are the essentials of good API design?




### Resource Identifiers
Resources should use Sequential UUIDs (SQUUIDs).

We chose SQUUIDs because they limit fragmentation of indexes and eliminate [performance problems in MySQL](http://www.percona.com/blog/2007/03/13/to-uuid-or-not-to-uuid/). __SQUUIDs are stored as binary(16)__

_SQUUIDs should be represented in string form as lowercase.  This is so that they can easily be joined across tables in the data warehouse._

#### Do Not Use Database Table Row IDs as Resource IDs
Auto-incrementing integer database row identifiers should not be used as Resource IDs or exposed in any way through the API.

Exposing DB table "auto-increment" row IDs as Resource IDs leaks implementation details outside the API. Row IDs couple the resource too closely to the underlying persistence engine and schema, and can cause headaches when the owning service might need to migrate away from a particular persistence engine or structure, or when clustering of several DBs becomes necessary. IDs not generated by autoincrementing column IDs allow for more flexibility.

#### Sample SQUUID Generator
```
def squuid
  This is basically the implementation of SecureRandom.uuid ...
  ary = SecureRandom.random_bytes(16).unpack("NnnnnN")
  ... but we replace the high-order 32 bits with the current time.
  ary[0] = Time.now.to_i
  ary[2] = (ary[2] & 0x0fff) | 0x4000
  ary[3] = (ary[3] & 0x3fff) | 0x8000
  "%08x-%04x-%04x-%04x-%04x%08x" % ary
end
```

### Versioning

#### Why Versioning?
API Versioning is an important aspect of API design because it informs the consumer about an API's capabilities and data. Consumers use the version number for compatibility.

#### Versioning Methods
Here are 2 of supported methods of API versioning:

* **Version in the HTTP Accept Header.** (*this is our preference*)
* Version in the URI.

We currently have some APIs that use Header-based versioning, and some that use URI-based versioning, in addition to deployed mobile apps that invoke URI-versioned APIs. Here is the direction we would like to take:

* Put the API Version in the HTTP Header for all new development.
* To avoid negatively impacting the current APIs under development, they can continue to use URI-based versioning for the time being.
* As opportunities arise, refactor all URI-versioned APIs to Header-based APIs.

##### Version in the HTTP `Accept` Header

```
GET
/inventory_items/4
Accept: application/vnd.livingsocial.v1+json
```
Here are the pros when putting the version in the HTTP `Accept` Header:

* The version is a representation of a resource, and (according to the [HTTP specification](https://tools.ietf.org/html/rfc2616)) this information goes in the HTTP Accept Header.
* It leverages a mechanism already provided by the HTTP specification. It's good to follow standards, and there's no need to invent something else.
* It is intellectually consistent with [Roy Fielding's dissertation on REST](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm).
* It supports content-based load balancing provided by web servers such as nginx.

Here are the cons:

* It's harder to test because you can't test it from a browser - you can't see the HTTP Headers without additional tooling.
  * But RESTful client plugins take care of this issue, and they are widely available for all major browsers. Plus, there are several good standalone RESTful API test tools.

##### Version in the URI
Many APIs put the version in the URI. Here's an example:

```
GET
/v1/inventory_items/4
```

Here are the pros when putting the version in the URI:

* It works well and is widely used by many of the major APIs on the Internet (e.g.,  Twitter, Yammer, Facebook, Google, etc.).
* It's simple and easy to read.
* It supports testing from a web browser.

Here are the cons:

* A URI identifies the location of resource, and the URI shouldn't change just because the data changes. A URI shouldn't change over time. A resource is a resource.
* A new URI should only be introduced when a new resource is created, not when it's representation or version changes.

#### Versioning Schemes
A pragmatic versioning scheme completes the overall API versioning strategy and addresses how to format the version number, when to upgrade and when to retire a version:

* We will base our approach on Semantic Versioning ([semver](http://semver.org/)) and Fear-Driven Versioning ([ferver](https://github.com/jonathanong/ferver)).
* We will only use a Major and Minor version in the form `x.y`, where `x` >= 1 and represents the Major version number, and `y` >= 0 and represents the Minor version number.
  * We never have a Major version of 0 because it makes the API appear unstable.
* There is no need to modify either the Major or Minor version for Non-Breaking changes.
* We change the Major version when:
  * There are multiple Breaking Changes.
  * There has been a significant change in the overall direction or philosophy of the API.
* We change the Minor version when there are 1 or more Breaking Changes.
* We retire a version after a certain period of time to give consumers/clients a chance to upgrade. For example, when we upgrade the Inventory Items API to version 2, we allow both version 1 & 2 to run concurrently for a certain period of before we sunset version 1.

##### Breaking Changes
A Breaking Change is any change to an API that could break a contract and cause consumer/client invocations of the API to fail. When changing an API, there are several things to think about when determining if a new version is needed or if the current version is still going to work for the client:

* Deprecating a feature (e.g., resource, Path, HTTP Verb, or JSON property).
* Refactoring a non-trivial portion of the API implementation.
* When a field's data type changes (e.g., the price changes format from string to float or vice-versa).
* When the format for a field changes (e.g., date formatting, currency).
* Updating an external dependency that the API relies on.
* Changing the Security model.

##### Non-Breaking Changes
A Non-Breaking Change is a change to the API that does not break a contract nor does impact the consumer/client. Here are some examples:

* Adding a new feature (e.g., Resource, Path, HTTP Verb, or JSON property).
* Upgrading documentation.

##### Resources for Versioning Schemes
Here are a few resources for dealing with the above issues:

* Semantic Versioning ([semver](http://semver.org/)). Many APIs and libraries use semver, which uses the following format for a version: `MAJOR.MINOR.PATCH`
* [Semver has failed us](http://www.jongleberry.com/semver-has-failed-us.html). A nice article on the shortcomings of semver, and shows how to improve it.
* Fear-Driven Versioning ([ferver](https://github.com/jonathanong/ferver)). This is based on semver, and makes some modifications. ferver has the notion of "breaking changes" and provides some guidelines there. They favor this version format: `MAJOR.MINOR`
* [Heroku's API Compatibility Policy](https://devcenter.heroku.com/articles/api-compatibility-policy) provides high-level guidelines on when to change and retire versions.

#### API Versioning Summary
Based on the research and discussions above, here are the high-level recommendations for versioning an API:

* Every API must have a version.
* Every API invocation must specify a version number.
* Versioning Methods:
  * All new APIs will put the version in the HTTP Accept Header.
  * All APIs currently under development can continue to use URI-based versioning for now, but will be refactored to use HTTP Accept Header in the near future.
* Versioning Schemes:
  * We will use a Major and Minor version in the form `x.y`, where `x` represents the Major version number, and `y` represents the Minor version number.
  * We change Major and Minor versions based on the degree and severity of the change to the API contract.

### Pagination

#### Why Pagination?
An API must be able to control/gate the amount data returned in the response so that the Consumer is able to handle the volume of data. If an API returns all instances of a given resource (e.g., inventory items, etc.) it could easily overrun the memory and processing capacity of the consumer. Pagination helps control the volume of data returned and makes it easier for the Consumer to process.

#### Pagination - Summary
Here are the high-level recommendations for API Pagination:
* Use the Facebook-style of Pagination that uses an `offset` and `limit` as follows: `/inventory_items?offset=543&limit=25`
  * The `offset` has semantic meaning. It is a sortable field/column based on the most optimal way to access the resource's data.
  * The `limit` has no semantic meaning. It is a simple integers that have no relation to the resource's data.
* Lead the Consumer through the API with links/URIs in the JSON response that show how to navigate.
  * Consider [HAL](https://tools.ietf.org/html/draft-kelly-json-hal-06) as a guide to specify these links/URIs.

#### Pagination Method
For our APIs, the `offset` is semantic - it could be a UUID, ID, a Date, etc. that is sortable. This semantic offset approach gives the API Producer (i.e., the developer who creates the API) a chance to choose an optimal way to do an offset into a result set based on a sortable field/column based on the most efficient way to access the resource's data. But the consumer will not provide the `offset` and `limit`; instead, the API itself provides this information to the Consumer.

#### Pagination - Leading the Consumer
An API should lead the consumer through the API invocations to help them reach a goal. In this case, we want to lead the consumer forward and backward through the result set rather than making them guess or keep track of where to go next. Each API should provide hyperlinks that provide URIs to the next and previous pages. This is an example of [HATEOAS (Hypertext as the Engine of Application State)](http://restcookbook.com/Basics/hateoas/), and here's what these hyperlinks might look like in a JSON response:

```
GET
/inventory_items?offset=100&limit=25
{
   "_links": {
     "self": {
       "href": "/inventory_items?offset=543&limit=25"
     },
     "next": {
       "href": "/inventory_items?offset=768&limit=25"
     },
     "prev": {
       "href": "/inventory_items?offset=123&limit=25"
     }
   },
   "items": [
     {
       "name": "Washington Nationals Game",
       "type": "Sporting Event",
       "price": "$35.00"
     }
     ...
  ]
}
```

In the above example, the `"_links"` property provides links to the consumer to help them navigate through the result set:

* `"self"` - The URI that was invoked.
* `"next"` - The next group of results.
* `"prev"` - The previous group of results.

This is a very simple implementation of [HAL (JSON Hypermedia API Language)](hhttps://tools.ietf.org/html/draft-kelly-json-hal-06). For further information, please visit the [HAL site](http://stateless.co/hal_specification.html).

#### Client Use of Pagination URIs
For client apps to use paginated APIs, it is necessary to embed the appropriate data from `_links` into the client views. For example, when the client displays a view containing paginated data, the `next` link must be embedded into the view so that the client web app knows where to fetch the next page of API data. Clients should avoid trying to construct new URLs to the API, but rather depend on the `next` and `previous` links returned by the API.

It is also recommended to encrypt the pagination URIs embedded in client views to prevent bad actors from making arbitrary calls to our backend services.

Given the example results in [Leading the Consumer](#pagination---leading-the-consumer), the client view might generate a links in its view like this ERB template example:
```ruby
<a href="/results?page=<%= encryptor.encrypt_and_sign("/inventory_items?offset=543&limit=25") %>">Next Page</a>
```

The controller that renders the `/results` view can use the value of the `page` parameter to fetch the next page of data from the API.


### API-Only Sub-Domains

If your API will be publicly accessible, contact Architecture to have a
discussion about hosting it under `api.livingsocial.com`, as there are
many potential benefits to doing so. 

### Filter/Sort/Search
Here are some general guidelines:
* Keep it simple.
  * Just use simple HTTP parameters.
  * Use a separate field for each filter/sort/search parameter.
* Avoid using a delimited set of fields (this anti-pattern is borrowed from the [Pearson API Guide](https://github.com/tfredrich/RestApiTutorial.com/raw/master/media/RESTful%20Best%20Practices-v1_2.pdf)):

  ```
  GET http://www.example.com/users?filter="name::bill|city::denver|title::developer"
  ```

  * The above is overly complex because it requires a `::` delimiter between the `filter` fields.

* Filter/sort/search on fields that are sortable field/column based on the most optimal way to access the resource's data (mot likely on a sortable/indexable column in the underlying database). Please see [Pagination](#pagination) for further details.
* For filter and search, there's no need for a `filter` or `query` because this is implied by the HTTP parameters.
* For sort, we should use an explicit `sort` parameter (to instruct the API to sort the response) as follows:
```
https://catalog-service.ls.net:443/offers.json?sort=city_id
```


### Content Negotiation
[Content Negotiation](http://en.wikipedia.org/wiki/Content_negotiation), part of the HTTP specification, is a mechanism that enables an API to serve a document/response in different formats (e.g., XML, JSON, etc.). Based on current industry best practices, we prefer JSON.

An API consumer can specify that they expect JSON in the response by using the HTTP Accept Header or by adding an extension to the URI. Here's how to specify the JSON [MIME type](http://en.wikipedia.org/wiki/Internet_media_type) in the HTTP `Accept` Header:

```
Accept: application/json
```

If JSON wasn't specified in the HTTP `Accept` Header, here's how to do this with a `.json` URI extension (Rails provides this by default).

```
.../cities/nearby/zipcode/1234.json
```

The HTTP `Content-Type` Header is the other header involved in Content Negotiation, and works as follows:
* An API consumer specifies that it provides JSON content in the request body (for `POST` and `PUT`).
* An API specifies that it provides JSON content in the response.

Here's how to specify the JSON [MIME type](http://en.wikipedia.org/wiki/Internet_media_type) in the HTTP `Content-Type` Header:

```
Content-Type: application/json
```

* API Producers:
  * For Rails-based APIs, Rails sets JSON MIME type headers by default.
  * For Clojure-based APIs, Clojure Ring Middleware sets JSON MIME type headers on behalf of the API (so that the handler doesn't have to deal with this).


### Security
Each API must address the following security concerns:
* Transport
* Authentication/Authorization
* CORS (Cross-Origin Resource Sharing)

#### Transport
Always use HTTPS to communicate with and between APIs. A best practice is to use TLS by default.

For internal APIs hosted in our IAD data center, this usually adds a performance penalty and can be dropped. As we move to AWS hosted services in 2016 and beyond, be sure to watch for this.

The goal here is confidentiality by hiding/encrypting sensitive information so that unauthorized 3rd parties cannot see the textual data transmitted between an API Producer and Consumer.

#### Authentication/Authorization
The purpose of Authentication is to validate a service consumer (i.e., subject/identity), which could be a:
* User
* A Mobile or Web application
* Another Service (either internal or external)

Authorization ensures that a subject/identity has permission to use/access services and resources in a system. Authorization usually occurs as part of or after Authentication. In this case, Authorization ensures that a service consumer has the right to access and use an API.

#### CORS (Cross-Origin Resource Sharing)
Web and mobile applications can only make HTTP requests to the site (i.e., domain) they're currently displaying. For example, if the UI is running on `www.myapp.com`, it can't perform an HTTP request against `www.yourapi.com`. There are 2 ways to handle this:
* [JSONP](http://en.wikipedia.org/wiki/JSONP) - JSONP (aka "JSON with Padding") provides a way to make an HTTP request against a different domain:
  * The API returns JavaScript rather than JSON.
  * The API consumer uses JavaScript to parse and interpret the response.
  * This is possible because browsers don't enforce the same-origin policy within `<script>` tags.
* [Cross-Origin Resource Sharing (CORS)](http://en.wikipedia.org/wiki/Cross-origin_resource_sharing) - CORS
  is recommended over JSONP because CORS is a [W3C standard](http://www.w3.org/TR/cors/) and supported by all modern browsers.

CORS defines a mechanism in which an API and its Consumers can collaborate to determine if it's safe to  allow the cross-origin request by leveraging HTTP Headers.

The `Origin` is the only relevant CORS-related HTTP Request Headers, and it indicates the origin (i.e., domain) of the cross-site access request. Upon receiving an HTTP Request, an API can check the `Origin` header's value (i.e., the originating domain - `myoriginatingdomain.com`, for example) against a whitelist of allowed domains. If the originating domain is __not__ found in the whitelist, then the API should return a 403 (`Forbidden`) Status Code.

Otherwise, if the originating domain is found in the whitelist, then the API performs the request and populates the following CORS-related HTTP Response Headers:

| HTTP Response Header | Description | Example |
| -------------------- | ----------- | ------- |
| `Access-Control-Allow-Origin` | Indicates whether a resource can be shared based by returning the value of: the `Origin` request header, `*`, or `null`. Even though `*` is allowed by the CORS spec, don't use it because this implies that every domain is acceptable. Use the value of the `Origin` request header instead. | `myoriginatingdomain.com` |
| `Access-Control-Allow-Credentials` | Indicates whether the response to a request can be exposed when the omit credentials flag is unset. When part of the response to a preflight request it indicates that the actual request can include user credentials.  | `true` |
| `Access-Control-Allow-Headers` | Indicates which HTTP headers are safe to expose to the API of a CORS API specification. | `Authorization` |
| `Access-Control-Allow-Methods` | Indicates, as part of the response to a pre-flight request, which HTTP Methods can be used during the actual request. | `GET`,  `POST`, `PUT`, `DELETE` |

##### CORS Implementations
There are a couple of good implementations:
* [rack-cors](https://github.com/cyu/rack-cors)

To have common/reusable CORS functionality in a single place across our APIs (i.e., the DRY Principle), we should consider:
* Populating the `Origin` Request Header from Mobile app and web applications.

#### Security References
* See "Securing Services", "Authentication", "Authorization", "Transport Security", and "Application Security" sections in the [Pearson eCollege RESTful Services Best Practices Guide](https://github.com/tfredrich/RestApiTutorial.com/raw/master/media/RESTful%20Best%20Practices-v1_2.pdf). Also see the "Handling Cross-Domain Issues" section.
* [CORS Specification](http://www.w3.org/TR/cors/)
* [Enable CORS](http://enable-cors.org/)
* See "Always use HTTPS" and "CORS" sections in [18F API Standards](https://github.com/18F/api-standards).


### Responses
When a Consumer invokes an API, one of three things can happen:
* Success - everything worked properly.
* Consumer Error - The Consumer (i.e., client) used bad data or there was a malformed request.
* API Error - The API (i.e., Producer, server) had a processing error.

Each API needs to handle errors and convey an appropriate status and error message in the HTTP Response.

#### HTTP Status Codes
Here is a list of the most common [HTTP Status Codes](http://www.restapitutorial.com/httpstatuscodes.html), their usage, and contextual meaning.

| HTTP Status Code | Applicable HTTP Verb / Method | Meaning                                                                                                                                                                                                   |
|:-----------------|:------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 200              | GET / PUT / DELETE            | `OK`. The API processed the request properly without error.                                                                                                                                               |
| 201              | POST                          | `Created`. API successfully created the Resource. The URI of the newly created Resource should go in the Location Header of the Response.                                                                 |
| 202              | POST / PUT / DELETE           | `Accepted`. The Request has been been received, has not been completed, and will be processed later.                                                                                                      |
| 204              | POST / PUT / DELETE           | `No Content`. API successfully processed the request, and is not returning data.                                                                                                                          |
| 301              | GET / PUT / DELETE            | `Moved Permanently`. This and all future requests should be directed to the new URI given in the Response.                                                                                                |
| 304              | GET                           | `Not Modified`. The resource hasn't changed since the previous GET request. Consumer must provide the following Headers: `Date`, `Content-location`, `ETag`.                                              |
| 400              | ALL                           | Bad Request. Due to Malformed URI or invalid data in the request parameters or body.                                                                                                                      |
| 401              | ALL                           | `Unauthorized`. Indicates that the Consumer has not provided appropriate credentials or that the supplied credentials are invalid.                                                                        |
| 403              | ALL                           | `Forbidden`. Similar to 401 (Unauthorized), but the API chose not to respond. This could be due to the fact that the HTTP Verb for the Request URI is not allowed.                                        |
| 404              | GET / PUT / DELETE            | `Not Found`. The API couldn't find the resource specified by the Request URI.                                                                                                                             |
| 409              | PUT                           | `Conflict`. The Request can't be processed due to an edit conflict on a resource. This could be caused by a race condition on the data to multiple updates from different consumers on the same resource. |
| 410              | ALL                           | `Gone`. The resource is unavailable and will not be available again.                                                                                                                                      |
| 500              | ALL                           | `Internal Server Error`. The request couldn't be processed due to a server-side processing exception.                                                                                                     |
| 501              | ALL                           | `Not Implemented`. The request is valid, but functionality has not been implemented for the HTTP Verb and Request URI.                                                                                    |
| 503              | ALL                           | `Service Unavailable`. The API (i.e., server) is temporarily unavailable. The server could be overloaded or down for maintenance.                                                                         |


#### Error Handling / Messages
Error Handling / Messaging requirements are different for Internal APIs and Consumer-Facing APIs.

##### Internal API Error Handling
[HTTP Status Codes](#http-status-codes) are sufficient for expressing statuses and error conditions for APIs that are consumed by other APIs. Internal APIs could handle errors (especially uncaught exceptions) and return the information in the JSON response as follows:

```
{
  "message": "Error message high-level description.",
  "exception": "[detailed stacktrace or error message]"
}
```

In production, we shouldn't have to put error messages in the response.

##### Consumer-Facing API Error Handling
Consumer-facing applications (both web and mobile) -  that consume an API and display error information to the end user - need more contextualized information is needed for consumer-facing applications. In this case, errors that include highly contextualized (localized, relevant to the action they're taking, etc) error messages would provide a much better experience to the user when there is an error.

Based on the [JSON API Error Formatting Guidelines](http://jsonapi.org/format/#errors), APIs used by consumer-facing applications __could__ provide the following fields in the error response:
* Required:
  * `code` - An application-specific error code, expressed as a string value.
* Optional:
  * `title` - A short, human-readable summary of the problem. It __should not__ change from occurrence to occurrence of the problem. This would be non-localized (i.e., English) because developers are the audience this.
  * `details` - A human-readable explanation specific to this occurrence of the problem. This would also be non-localized (i.e., English).
  * `user_message` - Localized error message, to be conveyed to the (mobile) end user.

Here's an example error message:

```
{
  "errors": [
    {
      "code": "unrecoverable_error",
      "title": "The flux capacitor disintegrated",
      "details": "Hold on, the end is nigh.",
      "user_message": {
        "default": "OMG, panic!",
        "en-GB": "Keep a stiff upper lip",
        "de-DE": "Schnell, schnell!!"
      }
    }
  ]
}
```

##### Response Validations

The `ls-api_validation` gem automates response validations. The gem looks at either your Swagger documentation or published [JSON Schema](https://github.com/ruby-json-schema/json-schema) documents to ensure your responses live up to their promises. In development `ls-api_validation` will raise an exception if the schema is invalid and in production it will validate a percentage of responses (1% by default) and log statuses. These actions are also configurable so you can set these to match your use cases.

##### Error Handling References
Here are some error handling examples from other API Design Guides:
* ["Generate structured errors" from the Heroku API Guide](https://github.com/interagent/http-api-design#generate-structured-errors).
* ["Error handling" in the 18F API Standards](https://github.com/18F/api-standards#error-handling).
* [JSON API Error Formatting Guidelines](http://jsonapi.org/format/#errors).

#### Response Envelopes and Hypermedia
Core RESTful principles are great at describing which HTTP verb to use and how to design manageable URIs. But there are two problems that need to addressed in the Response:
* Links between API endpoints/resources.
* Standardized response structures.

##### HAL Specification
Of the several Hypermedia specifications we reviewed (see [Hypermedia Specifications Considered](#hypermedia-specifications-considered)), we prefer [HAL](https://tools.ietf.org/html/draft-kelly-json-hal-06) because:
* It's simple and lightweight.
* The links (`_links`) and data (`_embedded`) don't impose heavy structural or formatting changes to the response data. The JSON response data still refelects the intent/structure of the original resource.
* Much of the specification is optional, so it's easy to comply with its requirements.

Here's an example:

```
   GET /orders/523 HTTP/1.1
   Host: example.org
   Accept: application/hal+json

   HTTP/1.1 200 OK
   Content-Type: application/hal+json

   {
     "_links": {
       "self": { "href": "/orders" },
       "next": { "href": "/orders?page=2" },
       "find": { "href": "/orders{?id}", "templated": true }
     },
     "_embedded": {
       "orders": [
         {
           "_links": {
             "self": { "href": "/orders/123" },
             "basket": { "href": "/baskets/98712" },
             "customer": { "href": "/customers/7809" }
           },
           "total": 30,
           "currency": "USD",
           "status": "shipped"
         },
         {
           "_links": {
             "self": { "href": "/orders/124" },
             "basket": { "href": "/baskets/97213" },
             "customer": { "href": "/customers/12369" }
           },
           "total": 20,
           "currency": "USD",
           "status": "processing"
         }
       ]
     },
     "currentlyProcessing": 14,
     "shippedToday": 20
   }
```

In the above document:
* The `_links` section at the root contains links for pagination (`self`, `next`) and search (`find`).
* The `_embedded` resources section contains:
  * An `orders` array, whose elements each contain:
    * Order properties: `total`, `currency` and `status`
    * Links to associated resources: `basket` and `customer`

Please note that the `_links` object is not required by each `order` object - it is optional in that context.

Here are the requirements for a simple valid HAL document:
* The Response Header must include the following MIME type: `application/hal+json`
* The root object __must__ be a Resource Object, which is one of:
  * `_links` - Optional. Contains links to other resources. The `links` object has several optional properties. Here's the main property, which is required:
    * `href` - Its value is either a [URI](https://tools.ietf.org/html/rfc3986) or a [URI Template](https://tools.ietf.org/html/rfc6570).
  * `_embedded` - Optional. Contains embedded resources, which could be a full or partial version of
     the representation served from the target URI.

HAL is simple and works well, and we should use it for every JSON response from our APIs. Here are a couple of example use cases for HAL:
* [Pagination](#pagination---leading-the-consumer---proposed)
* Reduce coupling and payload size for deep object hierarchies. For example, an `order` could have links to each `lineItem` that it contains rather than embedding the full content for the `lineItem` objects within the `order`.

##### Developer Libraries for working with HAL
Here's a list of [developer libraries for working with HAL](https://github.com/mikekelly/hal_specification/wiki/Libraries). The most promising libraries are:
* Rails:
  * [ROAR (Resource-Oriented Architectures in Ruby)](https://github.com/apotonick/roar/blob/master/lib/roar/json/hal.rb)
  * [Hyperresource](https://github.com/gamache/hyperresource)
  * [Hyperclient](http://codegram.github.io/hyperclient/)
  * [Hal-Client](https://github.com/pezra/hal-client)
* Clojure:
  * [halresource](https://github.com/cndreisbach/halresource)
* JavaScript
  * [hyperagent.js](http://weluse.github.io/hyperagent/)

The above list is a small subset of the [available HAL libraries](https://github.com/mikekelly/hal_specification/wiki/Libraries), so individual development teams should research and try out several options to find what works best for them.

##### Hypermedia Specifications Considered
There are several Hypermedia specifications that enable developers to link API responses and standardize API response formats:
* [HAL](https://tools.ietf.org/html/draft-kelly-json-hal-06)
* [JSON API](http://jsonapi.org/)
* [JSON-LD](http://json-ld.org/)
* [Siren](https://github.com/kevinswiber/siren)
* [Collections+JSON](http://amundsen.com/media-types/collection/examples/)

We reviewed the above options for a consistent envelope that standardizes:
* Data - The payload (the main data in the Response).
* Links - What can the consumer do next?
* Metadata - Documentation without requiring the consumer to read through the API docs.

In general, we found that all of the above met these needs, but there were issues with the Data and Metadata structures required by most of these specifications:
* Data - If this imposes too many structural and formatting changes to existing JSON Responses, then it's too heavy and obfuscates the meaning/structure of the resource data.
* Metadata - The embedded documentation required by these specifications seems too heavy to include in a JSON Response. The developer consuming the API can just read the API documentation.

##### Hypermedia References
* [On choosing a hypermedia type for your API - HAL, JSON-LD, Collection+JSON, Siren, Oh My!](http://sookocheff.com/posts/2014-03-11-on-choosing-a-hypermedia-format/)
* [Please, no more generic hypermedia types](http://www.bizcoder.com/please-no-more-generic-hypermedia-types)
* [The Hypermedia Debate](http://www.foxycart.com/blog/the-hypermedia-debate#.VXYJnVxViko)
* [JSON-LD and Why I Hate the Semantic Web](http://manu.sporny.org/2014/json-ld-origins-2/)
* [HAL specification](https://tools.ietf.org/html/draft-kelly-json-hal-06)
* [HAL site](https://github.com/mikekelly/hal_specification/wiki/Libraries)
* [HAL GH Repository](https://github.com/mikekelly/hal_specification)
* [HAL Primer](https://apigility.org/documentation/api-primer/representation-formats)
* MuleSoft:
  * [API Best Practices: Hypermedia (Part 1)](http://blogs.mulesoft.com/api-best-practices-hypermedia-part-1/)
  * [API Best Practices: Hypermedia (Part 2)](http://blogs.mulesoft.com/api-best-practices-hypermedia-part-2/)
  * [API Best Practices: Hypermedia (Part 3)](http://blogs.mulesoft.com/api-best-practices-hypermedia-part-3/)
* [Hypermedia API on Rails](http://guillecarlos.com/hypermedia-api-on-rails-04-24-2013.html)

#### Response Meta Data
Occasionally there will be a need to return meta-data about a response that doesn't belong in the JSON for the individual objects in the response. This data should go in a hash in a top level `meta` attribute. For instance, catalog-service can return offers using one of many different 'representations'. To include the name of the `representation` used for this particular response we might return something like this:

```
GET /offers/{guid}.json
{
  "meta": {
    "representation": "tile",
  },
  "offer": {
    "id": 123,
    ... other attrs ...
  }
}
```

```
GET /offers.json?some=search_query
{
  "meta": {
    "representation": "tile",
  },
  "offers": [ ..list of offers... ],
  ...
}
```

### JSON
Our APIs and Kafka messages use JSON because it is the format of choice for most modern Web APIs.
JSON provides interoperability and cleanly converts to programming constructs (i.e., objects, arrays, key/value pairs) in most development languages.



